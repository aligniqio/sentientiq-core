puts your API behind /api/* on the same domain (no CORS pain)

pulls the Clerk session from cookies (or passes Authorization if you already set it)

injects X-User-Id / X-Org-Id / X-Plan headers your usage gate can read today

cleanly streams SSE from /pulse

falls back to Free if no auth (so you can still demo)

1) netlify.toml (route all /api/* to the Edge proxy)

# netlify.toml
[edge_functions]
  # Route anything under /api/* to the edge proxy
  path = "/api/*"
  function = "api-proxy"

# (Optional) Set your API origin here, or in the Netlify UI env vars
[build.environment]
  API_ORIGIN = "https://<YOUR-EC2-OR-LB>:8000"

You can also set API_ORIGIN in Netlify’s dashboard → Site settings → Environment variables.

2) Edge function: netlify/edge-functions/api-proxy.ts

// netlify/edge-functions/api-proxy.ts
// Proxy /api/* -> your FastAPI, inject Clerk identity & plan headers.
// Works with Clerk cookies or Authorization header. Streams SSE cleanly.

export default async (request: Request, context: any) => {
  const apiOrigin = Deno.env.get("API_ORIGIN") ?? "http://localhost:8000";

  // Build target URL: /api/foo -> ${API_ORIGIN}/foo
  const url = new URL(request.url);
  const targetPath = url.pathname.replace(/^\/api/, "") || "/";
  const targetUrl = new URL(targetPath + url.search, apiOrigin);

  // Clone headers, drop hop-by-hop & set forward headers
  const headers = new Headers(request.headers);
  headers.delete("host");
  headers.set("x-forwarded-host", url.host);
  headers.set("x-forwarded-proto", url.protocol.replace(":", ""));

  // ---- Auth stitching (Clerk) ----
  // 1) If Authorization already set by frontend -> pass through
  let auth = headers.get("authorization");

  // 2) Else try Clerk session cookie (__session)
  if (!auth) {
    const cookie = headers.get("cookie") || "";
    const m = cookie.match(/(?:^|;\s*)__session=([^;]+)/);
    if (m) auth = `Bearer ${decodeURIComponent(m[1])}`;
  }

  if (auth) {
    headers.set("authorization", auth);

    // Soft-decode JWT payload (no verify; backend does gate).
    try {
      const payloadB64 = auth.split(" ")[1].split(".")[1];
      const json = JSON.parse(new TextDecoder().decode(base64UrlDecode(payloadB64)));
      const sub = json.sub || json.sid || "";
      const org = json.org_id || json.org || json.orgId || "";
      const plan =
        (json.public_metadata && (json.public_metadata.plan || json.public_metadata.tier)) ||
        (json.meta && (json.meta.plan || json.meta.tier)) ||
        "free";

      if (sub) headers.set("x-user-id", String(sub));
      if (org) headers.set("x-org-id", String(org));
      if (plan) headers.set("x-plan", String(plan).toLowerCase());
    } catch {
      // ignore decoding errors; backend can still resolve on its own
    }
  } else {
    // 3) Anonymous fallback: treat as Free
    headers.set("x-plan", "free");
  }

  // Keep SSE happy
  const isSSE = headers.get("accept")?.includes("text/event-stream") || targetPath.startsWith("/pulse");
  if (isSSE) {
    headers.set("accept", "text/event-stream");
    headers.set("cache-control", "no-cache");
  }

  // Handle preflight locally to keep things snappy (usually not needed if same-origin)
  if (request.method === "OPTIONS") {
    const respHeaders = new Headers({
      "access-control-allow-origin": url.origin,
      "access-control-allow-headers": headers.get("access-control-request-headers") || "*",
      "access-control-allow-methods": headers.get("access-control-request-method") || "GET,POST,OPTIONS",
      "access-control-max-age": "600",
    });
    return new Response(null, { status: 204, headers: respHeaders });
  }

  // Forward the request (stream body for POSTs)
  const init: RequestInit = {
    method: request.method,
    headers,
    body: ["GET", "HEAD"].includes(request.method) ? undefined : await request.arrayBuffer(),
    redirect: "manual",
  };

  const upstream = await fetch(targetUrl.toString(), init);

  // Mirror upstream response, preserving streaming for SSE
  const respHeaders = new Headers(upstream.headers);
  // Same-origin to browser, so CORS is typically moot, but harmless to expose:
  respHeaders.set("access-control-allow-origin", url.origin);

  return new Response(upstream.body, {
    status: upstream.status,
    statusText: upstream.statusText,
    headers: respHeaders,
  });
};

// --- helpers ---
function base64UrlDecode(b64url: string): Uint8Array {
  const pad = b64url.length % 4 === 2 ? "==" : b64url.length % 4 === 3 ? "=" : "";
  const b64 = b64url.replace(/-/g, "+").replace(/_/g, "/") + pad;
  const bin = atob(b64);
  const bytes = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
  return bytes;
}

What this gives you immediately

Frontend calls fetch('/api/ask', …) and never worries about tokens/CORS.

Your FastAPI sees:

Authorization: Bearer <clerk_jwt> (if present)

X-User-Id, X-Org-Id, X-Plan (decoded hints)

Your usage gate can run today (Free=20/month) and later switch to strict JWT parsing when Claude plugs the Stripe webhook → Clerk public metadata.

3) Frontend: point API calls to the proxy

Change your app config:

// Instead of hitting EC2 directly:
const API_BASE = import.meta.env.VITE_API_BASE || "/api";
// or in Next.js:
const API_BASE = process.env.NEXT_PUBLIC_API_BASE || "/api";

Then your existing calls (/ask, /pulse, /pulse/snapshot, /feedback) just work:
await fetch(`${API_BASE}/ask`, { method: "POST", ... })
const es = new EventSource(`${API_BASE}/pulse`); // SSE streams through


4) Local dev (optional): Vite proxy

If you want the same DX locally:

// vite.config.ts
export default defineConfig({
  server: {
    proxy: {
      "/api": {
        target: "http://localhost:8000",
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ""),
      },
    },
  },
});
Now your UI still calls /api/*, and Vite proxies to your FastAPI.

5) Env checklist

In Netlify:

API_ORIGIN = https://<YOUR-EC2-DNS-or-LB>:8000

(Your Clerk public keys/config are already set if login works)

In FastAPI (already done):

AUTH_MODE=clerk (or leave header while you test)

USAGE_STORE=memory (or dynamo later)

USAGE_SCOPE=user (or org for Team counting)

6) Sanity tests

From your local browser console (after deploy):

// Ask (free plan or signed-in Clerk user)
fetch("/api/ask", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ question: "Should we launch?", agent: "Emotion" })
}).then(r => r.json()).then(console.log)

// Pulse snapshot
fetch("/api/pulse/snapshot").then(r => r.json()).then(console.log)

// SSE stream
const es = new EventSource("/api/pulse");
es.onmessage = (e) => console.log("pulse", JSON.parse(e.data));

If signed in with Clerk, the proxy will grab __session and set Authorization automatically; otherwise it will inject X-Plan: free.

This gives you money-grade plumbing tonight:

single origin → no CORS drama

identity & plan headers → usage limits live now

seamless SSE → EVI stays real-time